package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"errors"
	"fmt"
	"log"
	"strconv"

	"github.com/altsaqif/graphql-go/cmd/helpers"
	"github.com/altsaqif/graphql-go/cmd/middlewares"
	"github.com/altsaqif/graphql-go/cmd/models"
	"github.com/altsaqif/graphql-go/graph/model"
	"golang.org/x/crypto/bcrypt"
)

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginRequest) (*model.LoginResponse, error) {
	var user models.User
	if err := r.DB.Where("email = ?", input.Email).First(&user).Error; err != nil {
		log.Println("User not found")
		return nil, err
	}

	// Verify password
	if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(input.Password)); err != nil {
		log.Println("Incorrect password")
		return nil, err
	}

	// Generate token
	tokenString, err := helpers.GenerateToken(input.Email)
	if err != nil {
		log.Println("Failed to generate token")
		return nil, err
	}

	// Set token to cookie
	// helpers.SetCookie(ctx, tokenString)

	return &model.LoginResponse{Token: tokenString}, nil
}

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, input model.RegisterRequest) (*model.RegisterResponse, error) {
	// Check if email already exists
	var existingUser models.User
	if err := r.DB.Where("email = ?", input.Email).First(&existingUser).Error; err == nil {
		return nil, fmt.Errorf("Email already exists")
	}

	// Hash password
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(input.Password), bcrypt.DefaultCost)
	if err != nil {
		log.Println("Failed to hash password")
		return nil, err
	}

	// Compare password with confirm_password
	if err := bcrypt.CompareHashAndPassword(hashedPassword, []byte(input.ConfirmPassword)); err != nil {
		return nil, fmt.Errorf("Password not matched")
	}

	// Create new user
	user := models.User{
		Name:            input.Name,
		Email:           input.Email,
		Password:        string(hashedPassword),
		PasswordConfirm: string(hashedPassword),
	}

	// Pastikan objek DB tidak nil sebelum menggunakannya
	if r.DB == nil {
		return nil, errors.New("DB connection is nil")
	}

	if err := r.DB.Create(&user).Error; err != nil {
		log.Println("Failed to create user")
		return nil, err
	}

	return &model.RegisterResponse{Message: "User registered successfully"}, nil
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context, input model.LogoutRequest) (*model.LogoutResponse, error) {
	// helpers.DeleteCookie(ctx, "token")
	// Clear token from cookie
	helpers.ClearCookie(ctx)
	return &model.LogoutResponse{Message: "Logged out successfully"}, nil
}

// CreateProduct is the resolver for the createProduct field.
func (r *mutationResolver) CreateProduct(ctx context.Context, input model.ProductRequest) (*model.ProductResponse, error) {
	// Get user from context
	user := middlewares.ForContext(ctx)
	if user == nil {
		return &model.ProductResponse{}, fmt.Errorf("Access denied")
	}

	// Check if product with the same ID already exists
	var existingProduct models.Product
	if err := r.DB.Where("name = ?", input.Name).First(&existingProduct).Error; err == nil {
		return nil, fmt.Errorf("Product with the same Name already exists")
	}

	// Create new product
	product := models.Product{
		Name:  input.Name,
		Stock: float64(input.Stock),
		Price: input.Price,
	}
	if err := r.DB.Create(&product).Error; err != nil {
		return nil, fmt.Errorf("Failed to create product")
	}

	return &model.ProductResponse{
		ID:    strconv.Itoa(product.ID),
		Name:  product.Name,
		Stock: int(product.Stock),
		Price: product.Price,
	}, nil
}

// UpdateProduct is the resolver for the updateProduct field.
func (r *mutationResolver) UpdateProduct(ctx context.Context, id string, input model.ProductRequest) (*model.ProductResponse, error) {
	// Get user from context
	user := middlewares.ForContext(ctx)
	if user == nil {
		return &model.ProductResponse{}, fmt.Errorf("Access denied")
	}

	// Check if product exists
	var existingProduct models.Product
	if err := r.DB.Where("id = ?", id).First(&existingProduct).Error; err != nil {
		return nil, fmt.Errorf("Product not found")
	}

	// Update product details
	existingProduct.Name = input.Name
	existingProduct.Stock = float64(input.Stock)
	existingProduct.Price = input.Price

	// Save changes
	if err := r.DB.Save(&existingProduct).Error; err != nil {
		return nil, fmt.Errorf("Failed to update product")
	}

	return &model.ProductResponse{
		ID:    strconv.Itoa(existingProduct.ID),
		Name:  existingProduct.Name,
		Stock: int(existingProduct.Stock),
		Price: existingProduct.Price,
	}, nil
}

// DeleteProduct is the resolver for the deleteProduct field.
func (r *mutationResolver) DeleteProduct(ctx context.Context, id string) (*model.Status, error) {
	// Get user from context
	user := middlewares.ForContext(ctx)
	if user == nil {
		return &model.Status{}, fmt.Errorf("Access denied")
	}

	// Check if product exists
	var existingProduct models.Product
	if err := r.DB.Where("id = ?", id).First(&existingProduct).Error; err != nil {
		return nil, fmt.Errorf("Product not found")
	}

	// Delete product
	if err := r.DB.Delete(&existingProduct).Error; err != nil {
		return nil, fmt.Errorf("Failed to delete product")
	}

	return &model.Status{Status: "Product deleted successfully"}, nil
}

// GetProductByID is the resolver for the getProductByID field.
func (r *queryResolver) GetProductByID(ctx context.Context, id string) (*model.ProductResponse, error) {
	// Get user from context
	user := middlewares.ForContext(ctx)
	if user == nil {
		return &model.ProductResponse{}, fmt.Errorf("Access denied")
	}

	var product models.Product
	if err := r.DB.Where("id = ?", id).First(&product).Error; err != nil {
		return nil, fmt.Errorf("Product not found")
	}

	return &model.ProductResponse{
		ID:    strconv.Itoa(product.ID),
		Name:  product.Name,
		Stock: int(product.Stock),
		Price: product.Price,
	}, nil
}

// GetAllProducts is the resolver for the getAllProducts field.
func (r *queryResolver) GetAllProducts(ctx context.Context) ([]*model.ProductResponse, error) {
	// Get user from context
	user := middlewares.ForContext(ctx)
	if user == nil {
		return []*model.ProductResponse{}, fmt.Errorf("Access denied")
	}

	var products []*models.Product
	if err := r.DB.Find(&products).Error; err != nil {
		return nil, fmt.Errorf("Failed to get products")
	}

	var productResponses []*model.ProductResponse
	for _, p := range products {
		productResponses = append(productResponses, &model.ProductResponse{
			ID:    strconv.Itoa(p.ID),
			Name:  p.Name,
			Stock: int(p.Stock),
			Price: p.Price,
		})
	}

	return productResponses, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
